DIGIT                       ::= ( 0-9 )
LETTER                      ::= ( A-Z | a-z )
EOF                         ::= <EOF>
LineTerminator              ::= <EOL>
StringLiteral               ::= <STRING_LITERAL>
HexLiteral                  ::= "0x" ( DIGIT | LETTER )+
DecimalLiteral              ::= ( DIGIT )* (  "." | "e" | " " )? ( DIGIT )*
NumberLiteral               ::= ( DecimalLiteral | HexaLiteral | "NaN" | "Infinity" )
Identifier                  ::= ( "_" | LETTER ) ( ( "_" | LETTER | DIGIT )* )?

Literal                     ::= ( StringLiteral | NumberLiteral | ArrayLiteral | "true" | "false" | "null" )
ArrayLiteral                ::= "[" ( ( Elision )? "]" | ElementList Elision "]" | ( ElementList )? "]" )
ElementList                 ::= ( Elision )? AssignmentExpression ( Elision AssignmentExpression )*
Elision                     ::= ( "," )+
ObjectLiteral               ::= "{" ( PropertyNameAndValueList )? "}"
DictionaryLiteral           ::= "{" ( KeyAndValuePairList ) "}"

PropertyNameAndValueList    ::= PropertyNameAndValue ( ( "," PropertyNameAndValue ) | "," )*
PropertyNameAndValue        ::= ( ( ( Identifier | StringLiteral |  NumberLiteral ) ":" AssignmentExpression ) | SpreadIdentifier )

KeyAndValuePairList         ::= KeyAndValuePair ( ( "," KeyAndValuePair ) | "," )*
KeyAndValuePair             ::= "[" ( AssignmentExpression "," AssignmentExpression )? "]"

PrimaryExpression           ::= "this" |  ObjectLiteral | DictionaryLiteral | ( "(" Expression ")" ) | Identifier | Literal
MemberExpression            ::= ( ( FunctionExpression | PrimaryExpression ) ( MemberExpressionPart )* )
MemberExpressionPart        ::= ( "[" Expression "]" ) | ( "." Identifier )

CallExpression              ::= MemberExpression Arguments ( CallExpressionPart )*
CallExpressionPart          ::= Arguments | ( "[" Expression "]" ) | ( "." Identifier )

Arguments                   ::= "(" ( ArgumentList )? ")"
ArgumentList                ::= AssignmentExpression ( "," AssignmentExpression )*

LeftHandSideExpression      ::= CallExpression | MemberExpression

UnaryExpression             ::= ( PostfixExpression | ( UnaryOperator UnaryExpression )+ )
UnaryOperator               ::= ( "typeof" | "sizeof" | "++" | "--" | "+" | "-" | "~" | "!" )

PostfixExpression           ::= LeftHandSideExpression ( PostfixOperator )?
PostfixOperator             ::= ( "++" | "--" )

MultiplicativeExpression    ::= UnaryExpression ( MultiplicativeOperator UnaryExpression )*
MultiplicativeOperator      ::= ( "*" | <SLASH> | "%" )

AdditiveExpression          ::= MultiplicativeExpression ( AdditiveOperator MultiplicativeExpression )*
AdditiveOperator            ::= ( "+" | "-" )

ShiftExpression             ::= AdditiveExpression ( ShiftOperator AdditiveExpression )*
ShiftOperator               ::= ( "<<" | ">>" | ">>>" )

RelationalExpression        ::= ShiftExpression ( RelationalOperator ShiftExpression )*
RelationalOperator          ::= ( "<" | ">" | "<=" | ">=" | "of" | "in" | "delete" | "pick" | "typeof" | "instanceof" )

EqualityExpression          ::= RelationalExpression ( EqualityOperator RelationalExpression )*
EqualityOperator            ::= ( "==" | "!=" | "===" | "!==" )

BitwiseANDExpression        ::= EqualityExpression ( BitwiseANDOperator EqualityExpression )*
BitwiseANDOperator          ::= "&"
BitwiseXORExpression        ::= BitwiseANDExpression ( BitwiseXOROperator BitwiseANDExpression )*
BitwiseXOROperator          ::= "^"
BitwiseORExpression         ::= BitwiseXORExpression ( BitwiseOROperator BitwiseXORExpression )*
BitwiseOROperator           ::= "|"

LogicalANDExpression        ::= BitwiseORExpression ( LogicalANDOperator BitwiseORExpression )*
LogicalANDOperator          ::= "&&"
LogicalORExpression         ::= LogicalANDExpression ( LogicalOROperator LogicalANDExpression )*
LogicalOROperator           ::= "||"

ConditionalExpression       ::= LogicalORExpression ( "?" AssignmentExpression ":" AssignmentExpression )?
AssignmentExpression        ::= ( LeftHandSideExpression AssignmentOperator AssignmentExpression | ConditionalExpression )
AssignmentOperator          ::= ( "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|=" )

Expression                  ::= AssignmentExpression ( "," AssignmentExpression )*
Statement                   ::=
  | Block
  | FunctionDeclaration
  | ClassDeclaration
  | LetStatement
  | VariableStatement
  | EmptyStatement
  | LabelledStatement
  | ExpressionStatement
  | IfStatement
  | IterationStatement
  | ContinueStatement
  | BreakStatement
  | ImportStatement
  | ReturnStatement
  | SwitchStatement
  | MatchStatement
  | ThrowStatement
  | TryStatement
  | InStatement
  | WithStatement
  | DeleteStatement
  | PickOfStatement
  | TypeofStatement
  | SizeofStatement
  | InstanceofStatement

StatementList               ::= ( Statement )+
VariableStatement           ::= ( "let" )? VariableDeclarationList
VariableDeclaration         ::= Identifier ( Initialiser )?
VariableDeclarationList     ::= VariableDeclaration ( "," VariableDeclaration )*
Initialiser                 ::= "=" AssignmentExpression
EmptyStatement              ::= LineTerminator | ";"
ExpressionStatement         ::= Expression ( EmptyStatement )?
BlockStatement              ::= "{" ( StatementList )? "}"
IfStatement                 ::= "if" Expression BlockStatement ( "else" BlockStatement )?

IterationStatement          ::=
  | ( "while" Expression BlockStatement )
  | ( "for" ( Expression )? ";" ( Expression )? ";" ( Expression )? ")" BlockStatement )
  | ( "for" Identifier "of" Expression ")" BlockStatement )

TypeStatement               ::=
  | ( "void" | "number" | "boolean" | "symbol" | "string" | "function" )
  | ( ( "object" | "array" ) ( "<" ( Identifier | TypeStatement ) ">" )? )

ThrowStatement              ::= "throw" Expression
TryStatement                ::= "try" BlockStatement ( ( Finally | Catch ( Finally )? ) )
Catch                       ::= "catch" Identifier? BlockStatement
Finally                     ::= "finally" BlockStatement

ContinueStatement           ::= "continue"
BreakStatement              ::= "break"
ReturnStatement             ::= "return" ( Expression )?
InStatement                 ::= Expression "in" Expression
WithStatement               ::= "with" Expression CallExpression
DeleteStatement             ::= Expression "delete" ( Expression | ParameterDestructuring )
PickStatement               ::= Expression "pick" ( Expression | ParameterDestructuring )
TypeofStatement             ::= "typeof" Expression
SizeofStatement             ::= "sizeof" Expression
InstanceofStatement         ::= Expression "instanceof" Expression

MatchStatement              ::= "match" Expression CaseBlock
SwitchStatement             ::= "switch" Expression CaseBlock
CaseBlock                   ::= "{" ( CaseClauses )? ( "}" | DefaultClause ( CaseClauses )? "}" )
CaseClauses                 ::= ( CaseClause )+
CaseClause                  ::= ( ( "case" Expression ":" ) ) ( StatementList )?

RangeStatment               ::= ( DecimalLiteral "..." DecimalLiteral )

ParameterIdentifier         ::= ( TypeStatement )? ( ( "..." )? Identifier ) ( PickStatement | Initialiser )?
ParameterList               ::= ParameterIdentifier ( "," ParameterIdentifier )*
ParameterDestructuring      ::= ( "{" ( ParameterList | RangeStatment )? "}" )

FunctionLambda              ::= ( ParameterList )? ( "returns" TypeStatement )? "=>" ( FunctionBody | ( ( LineTerminator )? Expression ) )
FunctionDeclaration         ::= "func" Identifier ( ParameterList )? ( "returns" TypeStatement )? FunctionBody
FunctionBody                ::= "{" ( SourceElements )? "}"

ClassDeclaration            ::= "class" Identifier ( ( ParameterList )? ( "extends" Identifier )? ) ClassBody
ClassBody                   ::= "{" ( ClassElements )? "}"
ClassElements               ::= ( ClassElement )+
ClassElement                ::= ( "public" | "private" | "protected" | "static" ) ( FunctionDeclaration | VariableDeclaration )

ModuleDeclaration            ::= "module" ( Identifier )? ModuleBody
ModuleBody                   ::= "{" ( SourceElements )? "}"

Program                     ::= ( SourceElements )? EOF
SourceElements              ::= ( SourceElement )+
SourceElement               ::= Statement

ExportImportStatement       ::= "export" ( "default" )? Expression ( FromStatement )?
FromStatement               ::= "from" ( Identifier | StringLiteral )
ImportIdentifier            ::= Identifier ( 'as' Identifier )?
ImportList                  ::= ImportIdentifier ( "," ImportIdentifier )*
ImportStatement             ::= "import" ( ImportList | ( "{" ImportList "}" ) ) FromStatement
