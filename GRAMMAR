DIGIT                       ::= ( 0-9 )
LETTER                      ::= ( A-Z | a-z )
EOF                         ::= <EOF>
LineTerminator              ::= <EOL>
StringLiteral               ::= <STRING_LITERAL>
HexLiteral                  ::= "0x" ( DIGIT | LETTER )+
DecimalLiteral              ::= ( DIGIT )* (  "." | "e" | " " )? ( DIGIT )*
NumberLiteral               ::= ( DecimalLiteral | HexaLiteral | "NaN" | "Infinity" )
Identifier                  ::= ( "_" | LETTER ) ( ( "_" | LETTER | DIGIT )* )?

Literal                     ::= ( StringLiteral | NumberLiteral | ArrayLiteral | "true" | "false" | "null" )
ArrayLiteral                ::= "[" ( ( Elision )? "]" | ElementList Elision "]" | ( ElementList )? "]" )
ElementList                 ::= ( Elision )? AssignmentExpression ( Elision AssignmentExpression )*
Elision                     ::= ( "," )+
ObjectLiteral               ::= "{" ( PropertyNameAndValueList )? "}"
PropertyNameAndValueList    ::= PropertyNameAndValue ( ( "," PropertyNameAndValue ) | "," )*
PropertyNameAndValue        ::= ( ( ( Identifier | StringLiteral |  NumberLiteral ) ":" AssignmentExpression ) | SpreadIdentifier )

PrimaryExpression           ::= "this" |  ObjectLiteral | ( "(" Expression ")" ) | Identifier | Literal
MemberExpression            ::= ( ( FunctionExpression | PrimaryExpression ) ( MemberExpressionPart )* )
MemberExpressionPart        ::= ( "[" Expression "]" ) | ( "." Identifier )

CallExpression              ::= MemberExpression Arguments ( CallExpressionPart )*
CallExpressionPart          ::= Arguments | ( "[" Expression "]" ) | ( "." Identifier )

Arguments                   ::= "(" ( ArgumentList )? ")"
ArgumentList                ::= AssignmentExpression ( "," AssignmentExpression )*

LeftHandSideExpression      ::= CallExpression | MemberExpression

UnaryExpression             ::= ( PostfixExpression | ( UnaryOperator UnaryExpression )+ )
UnaryOperator               ::= ( "typeof" | "sizeof" | "++" | "--" | "+" | "-" | "~" | "!" )

PostfixExpression           ::= LeftHandSideExpression ( PostfixOperator )?
PostfixOperator             ::= ( "++" | "--" )

MultiplicativeExpression    ::= UnaryExpression ( MultiplicativeOperator UnaryExpression )*
MultiplicativeOperator      ::= ( "*" | <SLASH> | "%" )

AdditiveExpression          ::= MultiplicativeExpression ( AdditiveOperator MultiplicativeExpression )*
AdditiveOperator            ::= ( "+" | "-" )

ShiftExpression             ::= AdditiveExpression ( ShiftOperator AdditiveExpression )*
ShiftOperator               ::= ( "<<" | ">>" | ">>>" )

RelationalExpression        ::= ShiftExpression ( RelationalOperator ShiftExpression )*
RelationalOperator          ::= ( "<" | ">" | "<=" | ">=" | "instanceof" | "in" )

EqualityExpression          ::= RelationalExpression ( EqualityOperator RelationalExpression )*
EqualityOperator            ::= ( "==" | "!=" | "===" | "!==" )

BitwiseANDExpression        ::= EqualityExpression ( BitwiseANDOperator EqualityExpression )*
BitwiseANDOperator          ::= "&"
BitwiseXORExpression        ::= BitwiseANDExpression ( BitwiseXOROperator BitwiseANDExpression )*
BitwiseXOROperator          ::= "^"
BitwiseORExpression         ::= BitwiseXORExpression ( BitwiseOROperator BitwiseXORExpression )*
BitwiseOROperator           ::= "|"

LogicalANDExpression        ::= BitwiseORExpression ( LogicalANDOperator BitwiseORExpression )*
LogicalANDOperator          ::= "&&"
LogicalORExpression         ::= LogicalANDExpression ( LogicalOROperator LogicalANDExpression )*
LogicalOROperator           ::= "||"

ConditionalExpression       ::= LogicalORExpression ( "?" AssignmentExpression ":" AssignmentExpression )?
AssignmentExpression        ::= ( LeftHandSideExpression AssignmentOperator AssignmentExpression | ConditionalExpression )
AssignmentOperator          ::= ( "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|=" )

Expression                  ::= AssignmentExpression ( "," AssignmentExpression )*
Statement                   ::=
  | Block
  | FunctionDeclaration
  | ClassDeclaration
  | LetStatement
  | VariableStatement
  | EmptyStatement
  | LabelledStatement
  | ExpressionStatement
  | IfStatement
  | IterationStatement
  | ContinueStatement
  | BreakStatement
  | ImportStatement
  | ReturnStatement
  | SwitchStatement
  | MatchStatement
  | ThrowStatement
  | TryStatement

StatementList               ::= ( Statement )+
BlockStatement              ::= "{" ( StatementList )? "}"
VariableStatement           ::= "let" VariableDeclaration
Initialiser                 ::= "=" AssignmentExpression
EmptyStatement              ::= LineTerminator | ";"
ExpressionStatement         ::= Expression ( EmptyStatement )?
IfStatement                 ::= "if" Expression BlockStatement ( "else" BlockStatement )?

IterationStatement          ::=
  | ( "while" Expression BlockStatement )
  | ( "for" VariableDeclaration ";" ( Expression )? ";" ( Expression )? ")" BlockStatement )
  | ( "for" VariableDeclaration "in" Expression ")" BlockStatement )

ContinueStatement           ::= "continue"
BreakStatement              ::= "break"
ReturnStatement             ::= "return" ( Expression )?
InstanceofStatement         ::= Expression "instanceof" Expression
TypeofStatement             ::= "typeof" Expression
SizeofStatement             ::= "sizeof" Expression

MatchStatement              ::= "match" Expression CaseBlock
SwitchStatement             ::= "switch" Expression CaseBlock
CaseBlock                   ::= "{" ( CaseClauses )? ( "}" | DefaultClause ( CaseClauses )? "}" )
CaseClauses                 ::= ( CaseClause )+
CaseClause                  ::= ( ( "case" Expression ":" ) ) ( StatementList )?

ThrowStatement              ::= "throw" Expression
TryStatement                ::= "try" BlockStatement ( ( Finally | Catch ( Finally )? ) )
Catch                       ::= "catch" Identifier? BlockStatement
Finally                     ::= "finally" BlockStatement

PickStatement               ::= "pick" "{" ( ParameterList )? "}"
TypeStatement               ::=
  | ( "void" | "number" | "boolean" | "symbol" | "string" | "function" | "any" )
  | ( ( "object" | "array" ) ( "<" ( Identifier | TypeStatement ) ">" )? )

SpreadIdentifier            ::= ( "..." )? Identifier
ParameterIdentifier         ::= ( TypeStatement )? SpreadIdentifier ( PickStatement | Initialiser )?
ParameterList               ::= ParameterIdentifier ( "," ParameterIdentifier )*

FunctionLambda              ::= ( ParameterList )? ( TypeStatement )? "=>" ( FunctionBody | ( ( LineTerminator )? Expression ) )
FunctionDeclaration         ::= "func" Identifier ( ParameterList )? ( TypeStatement )? FunctionBody
FunctionBody                ::= "{" ( SourceElements )? "}"

ClassDeclaration            ::= "class" Identifier ( ( ParameterList )? ( "extends" Identifier )? ) ClassBody
ClassBody                   ::= "{" ( ClassElements )? "}"
ClassElements               ::= ( ClassElement )+
ClassElement                ::= ( "public" | "private" | "protected" | "static" ) ( FunctionDeclaration | VariableDeclaration )

ModuleDeclaration            ::= "module" ( Identifier )? ModuleBody
ModuleBody                   ::= "{" ( SourceElements )? "}"

Program                     ::= ( SourceElements )? EOF
SourceElements              ::= ( SourceElement )+
SourceElement               ::= Statement

ExportImportStatement       ::= "export" ( "default" )? Expression ( FromStatement )?
FromStatement               ::= "from" ( Identifier | StringLiteral )
ImportIdentifier            ::= Identifier ( 'as' Identifier )?
ImportList                  ::= ImportIdentifier ( "," ImportIdentifier )*
ImportStatement             ::= "import" ( ImportList | ( "{" ImportList "}" ) ) FromStatement

LetStatement                ::= "let" LetDeclarationList
LetDeclarationList          ::= LetDeclaration ( "," LetDeclaration )*
