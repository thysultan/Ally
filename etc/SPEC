blob [...meta, scope, func, size, ...data]
call (len, arg, env)
fun : fun[-2](sizeof(arg)/i64, arg[...], fun[-3]) [...meta,next,scope(function),func,size=0]
obj : obj[-2](sizeof(arg)/i64, arg[...], obj[-3]) [...meta,next,scope(object),func,size=sizeof(props),props]
str : str[-2](sizeof(arg)/i64, arg[...], str[-3]) [...meta,next,scope(box(string)),func,size=sizeof(chars),chars]
int : var[-2](sizeof(arg)/i64, arg[...], var[-3]) [...meta,next,scope(box(number)),func,size=0,number]
flt : var[-2](sizeof(arg)/i64, arg[...], var[-3]) [...meta,next,scope(box(number)),func,size=0,number]
var : var[-2](sizeof(arg)/i64, arg[...], var[-3]) [...meta,next,scope(box(variable)),func,size=0,variable]

the next link is for creating chains of data that are only flattened on read, i.e pushing an element to an array may mearly create a small wrapper pointing to a chain of segments of the array
with each segment symbolising a operation to be actuallized in it's flat form on read and actually this flattening operation on only the first read
